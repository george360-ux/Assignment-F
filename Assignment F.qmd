---
title: "Assignment F"
format: html
editor: visual
---

## Introduction to Github Team Workflow - Branches

List of references:

-   <https://git-scm.com/book/en/v2/Git-Branching-Basic-Branching-and-Merging>

-   <https://www.atlassian.com/git/tutorials/comparing-workflows/feature-branch-workflow?utm_source=chatgpt.com>

-   <https://docs.github.com/en/get-started/using-github/github-flow?utm_source=chatgpt.com>

-   <https://docs.github.com/en/account-and-profile/how-tos/setting-up-and-managing-your-personal-account-on-github/managing-access-to-your-personal-repositories/inviting-collaborators-to-a-personal-repository?utm_source=chatgpt.com>

As a part of this assignment, you are also required to complete all the exercises in the Introduction Sequence on the 'Main' tab and 1-4 on Push & Pull on the 'Remote' tab. ( <https://learngitbranching.js.org/?locale=en_US>)

You want all the boxes in "level selection" to be green to show you have completed them.  You can retrieve what your progress looks like at any time by clicking on the little question mark in the bottom right hand corner and clicking 'Levels'. Once you have completed the requisite exercises, upload screenshots of "Level Selection" in the repository with folder called "learn git branching"

## Assignment Instructions

This assignment will be a Team work. We will decide number of teammates based on total students present in the class (\~26 students)

Following are the themes of work (Based on Strawberry Data set) for different groups:

1.  Fungicides \[Organic vs Conventional by state\]
2.  Herbicides \[Organic vs Conventional by state\]
3.  Insecticides \[Organic vs Conventional by state\]
4.  Fertilizers \[Organic vs Conventional by state\]
5.  Other Chemicals \[Organic vs Conventional by state\]
6.  Yield \[Organic vs Conventional by state\]
7.  Profitability \[Price, Volume, Variable Cost, Fixed Cost\]
8.  Markets
9.  Transportation (Logistics)

All of above is in addition to the data cleaning of Strawberry data set talked about in the class.

### Deliverable

Each team will submit a **GitHub repository** that includes:

-   **Main branch**

```         
-    Final Report (`.pdf`, `.html`, and `.qmd`)

-    Cleaned data sets (`.csv`)

-    Well-written `README.md` file describing your project

-    Any scripts or code files used

-   Folder called "learn git branching" containing images of the "level selection" (main and remote)
```

-   **Clear organization:** The repository should be understandable to someone unfamiliar with your project. (with logical folder structure, clear file names, and documented steps)

Your **final report** should include:

-   Overview of the topic and research question

-   Description of the data cleaning process

-   Key analyses and findings

-   **Visualizations** with thoughtful explanations

-   If needed, integration of **external data sources** relevant to your theme

### Secondary Objective — *Industry-Level Git Collaboration*

In addition to the data analysis, this assignment is also designed to help you **experience real-world teamwork on GitHub**, just as teams do in industry.

So make sure your group:

1.  Works within a **shared GitHub repository** (one repo per team).

2.  Invites all teammates as **collaborators** (no forks).

3.  Uses **branches** for individual work (`feature-username`, `analysis-theme`, etc.).

4.  Opens **pull requests** to merge branches into `main` after peer review.

5.  Practices **resolving merge conflicts**, **pulling latest changes**, and maintaining a clean commit history.

6.  Protects the `main` branch to require pull requests (no direct pushes).

```{r}
# Load required packages
library(tidyverse)
library(janitor)
library(stringr)

# Load dataset
strawberry <- read_csv("~/Documents/MA-615/strawberry_10oct25.csv", show_col_types = FALSE)

# --- STEP 1: Standardize column names ---
strawberry <- strawberry %>% janitor::clean_names()   # e.g. "Value" -> "value", "Data Item" -> "data_item"

# --- STEP 2: Remove constant columns ---
remove_constant_columns <- function(df) {
  df[, sapply(df, function(col) length(unique(col)) > 1)]
}

#if(is.null(drop))[return("name")]

strawberry <- remove_constant_columns(strawberry)
remove_constant_columns(strawberry)

#Trim whitespace in all character columns ---
strawberry <- strawberry %>% mutate(across(where(is.character), str_trim))

#Clean 'data_item' column if present ---
if ("data_item" %in% names(strawberry)) {
  strawberry <- strawberry %>%
    mutate(data_item = str_remove(data_item, "^STRAWBERRIES(\\s*-\\s*|,\\s*)"))
}

# Robust detection of numeric / value column and remove rows missing it ---
# Compute for each column the proportion of entries that parse as numeric (after removing commas)
numeric_prop <- sapply(strawberry, function(col) {
  col_chr <- as.character(col)
  col_chr[col_chr == ""] <- NA
  col_clean <- gsub(",", "", col_chr)
  num <- suppressWarnings(as.numeric(col_clean))
  mean(!is.na(num))
})

# Pick best candidate (highest proportion of numeric parses)
best_candidate <- names(numeric_prop)[which.max(numeric_prop)]
best_prop <- numeric_prop[best_candidate]

# If best candidate has very low numeric proportion, try name-based fallback
if (best_prop < 0.15) {
  name_matches <- grep("value|amount|estimate|qty|quantity|measure|tons|kg|lbs", names(strawberry), ignore.case = TRUE, value = TRUE)
  if (length(name_matches) > 0) {
    best_candidate <- name_matches[1]
    best_prop <- numeric_prop[best_candidate]
  }
}

message(sprintf("Using column '%s' as the 'value' column (numeric parse proportion = %.2f).",
                best_candidate, best_prop))

# Now coerce that column to numeric (remove commas) and filter out NA / blank rows
strawberry <- strawberry %>%
  mutate(
    !!best_candidate := {
      col_chr <- as.character(.data[[best_candidate]])
      col_chr[col_chr == ""] <- NA
      suppressWarnings(as.numeric(gsub(",", "", col_chr)))
    }
  ) %>%
  filter(!is.na(.data[[best_candidate]]))

# --- STEP 6: Convert columns to correct types safely ---
# Only mutate columns that actually exist

if ("state" %in% names(strawberry)) {
  strawberry <- strawberry %>%
    mutate(state = as.factor(state))
}

if ("data_item" %in% names(strawberry)) {
  strawberry <- strawberry %>%
    mutate(data_item = as.factor(data_item))
}

if ("year" %in% names(strawberry)) {
  strawberry <- strawberry %>%
    mutate(year = as.integer(year))
}
# --- STEP 7: Remove duplicate rows ---
#strawberry <- strawberry %>% distinct()



```

```{r}
# Data splitting 
strawb_census <- strawberry|> filter(program=="CENSUS")
strawb_survey <- strawberry|> filter(program=="SURVEY")
census_data_items <- strawb_census |> distinct(`data_item`)

# Examine Strawberry survey
surv_data_item <- strawb_survey |> distinct(`data_item`)

#  Split by state
if ("state" %in% names(strawberry)) {
  strawberry_by_state <- strawberry %>%
    group_split(state)
  names(strawberry_by_state) <- unique(strawberry$state)
}

#  Split by year (for trend exploration)
if ("year" %in% names(strawberry)) {
  strawberry_by_year <- strawberry %>%
    group_split(year)
  names(strawberry_by_year) <- unique(strawberry$year)
}

# Assign each state as it's own dataframe
for (st in names(strawberry_by_state)) {
  # Replace spaces with underscores and make lowercase for valid variable names
  df_name <- st %>%
    str_to_lower() %>%
    str_replace_all("\\s+", "_")
  
  # Assign each element to the global environment
  assign(df_name, strawberry_by_state[[st]], envir = .GlobalEnv)
}

state_summary <- strawberry %>%
  group_by(state) %>%
  summarise(
    avg_value = mean(value, na.rm = TRUE),
    total_value = sum(value, na.rm = TRUE),
    n_obs = n()
  ) %>%
  arrange(desc(total_value))

year_summary <- strawberry %>%
  group_by(year) %>%
  summarise(
    avg_value = mean(value, na.rm = TRUE),
    total_value = sum(value, na.rm = TRUE),
    n_obs = n()
  )

# Potash
# Nitrogen
# Sulfur
# Find out what harms or benefits it has to strawberyr (ME)
# Why it might be a great fertlizer
# Why fertilizer is important 
```

```{r}

# FINAL FIXED CLEANING PIPELINE
library(tidyverse)
library(janitor)
library(stringr)

# --- 1. Clean column names
clean_column_names <- function(df) {
  df %>% janitor::clean_names()
}

# --- 2. Remove empty or constant columns
remove_empty_constant_cols <- function(df) {
  df %>%
    dplyr::select_if(function(col) !all(is.na(col))) %>%
    dplyr::select_if(function(col) dplyr::n_distinct(col, na.rm = TRUE) > 1)
}

# --- 3. Trim whitespace
trim_whitespace <- function(df) {
  df %>% mutate(across(where(is.character), str_trim))
}




# --- 5. Rename domain_category -> fertilizer and clean it
clean_domain_to_fertilizer <- function(df) {
  # Only do this if domain_category exists
  if (!"domain_category" %in% names(df)) return(df)
  
  df %>%
    # rename first to avoid accidental overwrites
    rename(fertilizer = domain_category) %>%
    mutate(
      # remove leading "FERTILIZER:" or similar
      fertilizer = str_remove(fertilizer, regex("^FERTILIZER[:\\s\\-]*", ignore_case = TRUE)),
      # If fertilizer info is inside parentheses like "FERTILIZER: (NITROGEN)" extract inside
      fertilizer = str_replace(fertilizer, regex("^\\s*\\(([^)]+)\\).*", ignore_case = TRUE), "\\1"),
      # remove trailing measured/unit phrases
      fertilizer = str_remove(fertilizer, regex(",\\s*MEASURED.*$", ignore_case = TRUE)),
      fertilizer = str_remove(fertilizer, regex("\\bMEASURED.*$", ignore_case = TRUE)),
      # remove extra punctuation
      fertilizer = str_remove_all(fertilizer, "[()\\[\\]]"),
      fertilizer = str_replace_all(fertilizer, "[-_]+", " "),
      fertilizer = str_squish(fertilizer),
      fertilizer = str_to_title(fertilizer)
    )
}

# --- 6. Smarter numeric detection & cleaning (skip identifier and fertilizer)
clean_numeric_value <- function(df) {
  numeric_prop <- sapply(df, function(col) {
    col_chr <- as.character(col)
    col_chr[col_chr == ""] <- NA
    col_clean <- gsub(",", "", col_chr)
    num <- suppressWarnings(as.numeric(col_clean))
    mean(!is.na(num))
  })
  
  ignore_cols <- c(
    "year","state","state_ansi","ag_district_code","county_ansi",
    "watershed_code","domain","domain_category","week","month","location","fertilizer","data_item"
  )
  numeric_prop <- numeric_prop[!names(numeric_prop) %in% ignore_cols]
  
  # safety: if all remaining numeric_prop are NA/zero, try including common names
  if (all(is.na(numeric_prop)) || length(numeric_prop) == 0) {
    potential <- c("value","amount","estimate","quantity","tons","kg","lbs")
    potential_found <- intersect(names(df), potential)
    if (length(potential_found) > 0) {
      best_candidate <- potential_found[1]
    } else {
      stop("No suitable numeric column detected. Check your data headers.")
    }
  } else {
    best_candidate <- names(numeric_prop)[which.max(numeric_prop)]
  }
  
  message("Detected numeric column: ", best_candidate)
  
  df <- df %>%
    mutate(
      !!best_candidate := suppressWarnings(as.numeric(gsub(",", "", .data[[best_candidate]])))
    )
  
  if (!"value" %in% names(df) && best_candidate != "value") {
    df <- df %>% rename(value = !!sym(best_candidate))
  }
  df
}

# --- 7. Convert types safely
convert_data_types <- function(df) {
  df %>%
    mutate(
      state = if ("state" %in% names(.)) as.factor(state) else state,
      year  = if ("year" %in% names(.)) as.integer(year) else year,
      fertilizer = if ("fertilizer" %in% names(.)) as.factor(fertilizer) else fertilizer,
      data_item = if ("data_item" %in% names(.)) as.factor(data_item) else data_item
    )
}

# --- 8. Final cleanup
final_cleanup <- function(df) {
  df %>%
    filter(!is.na(value) & value > 0) %>%
    distinct()
}

# --- Master pipeline
clean_strawberry_fertilizer <- function(path,
                                       drop_state_ansi = TRUE,
                                       save_clean = FALSE,
                                       save_path = "strawberry_fertilizers_clean.csv") {
  df <- read_csv(path, show_col_types = FALSE) %>%
    clean_column_names()
  
  if (drop_state_ansi) {
    df <- df %>% dplyr::select(-dplyr::any_of("state_ansi"))
  }
  
  df <- df %>%
    remove_empty_constant_cols() %>%
    trim_whitespace() %>%           # clean raw data_item (keeps as data_item)
    clean_domain_to_fertilizer() %>% # rename domain_category -> fertilizer and clean it
    clean_numeric_value() %>%
    convert_data_types() %>%
    final_cleanup()
  
  if (save_clean) write_csv(df, save_path)
  df
}

# ---- Example usage:
fert_clean <- clean_strawberry_fertilizer("~/Documents/MA-615/strawberry_fertilizers.csv", drop_state_ansi = TRUE)
glimpse(fert_clean)
unique(fert_clean$fertilizer)
unique(fert_clean$data_item)

```

```{r}
fert_clean <- fert_clean %>% 
  mutate(data_item = str_remove(data_item, ".*-")) 

fert_clean <- fert_clean %>%
  pivot_wider(
    id_cols = c(year, state),  # Columns that uniquely identify each new wide row
    names_from = c(fertilizer, data_item), # Columns whose values will become the new column names
    values_from = value   # Column whose values will fill the new columns
  )
```

**Exploratory Data Analysis**

```{r}
summary(fert_clean[, c("Nitrogen_ APPLICATIONS, MEASURED IN LB",
                       "Phosphate_ APPLICATIONS, MEASURED IN LB",
                       "Potash_ APPLICATIONS, MEASURED IN LB",
                       "Sulfur_ APPLICATIONS, MEASURED IN LB")])
```

Nitrogen is typically the highest by mass which is vital for foliage growth. Potash and Phosphate supports fruit quality and sulfure appears occasionally, often for pH management or pest control (common in organic systems)

```{r}
library(ggplot2)
fert_by_state <- fert_clean %>%
  group_by(state) %>%
  summarise(
    Nitrogen = mean(`Nitrogen_ APPLICATIONS, MEASURED IN LB`, na.rm = TRUE),
    Phosphate = mean(`Phosphate_ APPLICATIONS, MEASURED IN LB`, na.rm = TRUE),
    Potash = mean(`Potash_ APPLICATIONS, MEASURED IN LB`, na.rm = TRUE),
    Sulfur = mean(`Sulfur_ APPLICATIONS, MEASURED IN LB`, na.rm = TRUE)
  ) %>%
  pivot_longer(-state, names_to = "Fertilizer", values_to = "Mean_Lb")

ggplot(fert_by_state, aes(x = state, y = Mean_Lb, fill = Fertilizer)) +
  geom_col(position = "dodge") +
  labs(title = "Average Fertilizer Use by State",
       y = "Average Pounds Applied", x = "State") +
  theme_minimal()


```

```{r}
fert_trend <- fert_clean %>%
  group_by(year) %>%
  summarise(
    Nitrogen = mean(`Nitrogen_ APPLICATIONS, MEASURED IN LB`, na.rm = TRUE),
    Phosphate = mean(`Phosphate_ APPLICATIONS, MEASURED IN LB`, na.rm = TRUE),
    Potash = mean(`Potash_ APPLICATIONS, MEASURED IN LB`, na.rm = TRUE)
  ) %>%
  pivot_longer(-year, names_to = "Fertilizer", values_to = "Mean_Lb")

ggplot(fert_trend, aes(x = year, y = Mean_Lb, color = Fertilizer)) +
  geom_line(size = 1.2) +
  geom_point() +
  labs(title = "Fertilizer Use Trends Over Time (US Strawberries)",
       y = "Mean Pounds Applied", x = "Year") +
  theme_minimal()


```

Nitrogen and Potash usage have declined slightly since early 2000s, hinting at improved efficiencty or organic adoption. Phosphate uses stabilizes - excess phosphorus runoff is an enviornmental issue

```{r}



```
